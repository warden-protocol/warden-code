<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Agent</title>
        <style>
            *,
            *::before,
            *::after {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    "SF Mono", "Fira Code", "Fira Mono", "Roboto Mono",
                    "Courier New", monospace;
                background: #0c0c0c;
                color: #d4d4d4;
                height: 100vh;
                display: flex;
                flex-direction: column;
                /* Dot grid background */
                background-image: radial-gradient(
                    circle,
                    #1a1a1a 1px,
                    transparent 1px
                );
                background-size: 24px 24px;
            }

            /* Header */
            header {
                padding: 14px 28px;
                border-bottom: 1px solid #1e1e1e;
                display: flex;
                align-items: center;
                justify-content: space-between;
                flex-shrink: 0;
                gap: 12px;
                background: rgba(12, 12, 12, 0.9);
                backdrop-filter: blur(12px);
            }
            .agent-meta {
                display: flex;
                align-items: center;
                gap: 10px;
                min-width: 0;
            }
            .agent-name {
                font-size: 14px;
                font-weight: 600;
                color: #f0f0f0;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                letter-spacing: 0.02em;
            }
            .agent-version {
                font-size: 10px;
                color: #555;
                border: 1px solid #2a2a2a;
                padding: 2px 8px;
                border-radius: 3px;
                white-space: nowrap;
                letter-spacing: 0.05em;
            }
            .wallet-area {
                display: flex;
                gap: 8px;
                align-items: center;
                flex-shrink: 0;
            }
            .wallet-info {
                font-size: 11px;
                color: #c7ff8e;
            }
            .phantom-info {
                font-size: 11px;
                color: #ab9ff2;
            }

            /* Info bar with corner brackets */
            .info-bar {
                padding: 20px 28px;
                border-bottom: 1px solid #1e1e1e;
                flex-shrink: 0;
                position: relative;
                background: rgba(12, 12, 12, 0.6);
            }
            .info-bar::before,
            .info-bar::after {
                content: "";
                position: absolute;
                width: 12px;
                height: 12px;
                border-color: #333;
                border-style: dashed;
                border-width: 0;
            }
            .info-bar::before {
                top: 8px;
                left: 12px;
                border-top-width: 1px;
                border-left-width: 1px;
            }
            .info-bar::after {
                bottom: 8px;
                right: 12px;
                border-bottom-width: 1px;
                border-right-width: 1px;
            }
            .agent-description {
                font-size: 12px;
                color: #777;
                line-height: 1.6;
                margin-bottom: 10px;
                max-width: 600px;
            }
            .agent-description:empty {
                margin-bottom: 0;
            }
            .capabilities-row {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-bottom: 10px;
            }
            .capabilities-row:empty {
                margin-bottom: 0;
            }
            .cap-badge {
                font-size: 9px;
                color: #666;
                border: 1px solid #2a2a2a;
                padding: 3px 10px;
                border-radius: 2px;
                text-transform: uppercase;
                letter-spacing: 0.1em;
            }
            .provider-row {
                margin-top: 10px;
                font-size: 10px;
                color: #555;
                letter-spacing: 0.05em;
                text-transform: uppercase;
            }
            .provider-row a {
                color: #777;
                text-decoration: none;
                border-bottom: 1px dashed #444;
            }
            .provider-row a:hover {
                color: #f0f0f0;
            }

            /* Reputation display */
            .reputation-row {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-top: 10px;
            }
            .reputation-badge {
                font-size: 11px;
                color: #d4d4d4;
                border: 1px solid #333;
                padding: 4px 12px;
                border-radius: 2px;
                letter-spacing: 0.02em;
            }
            .reputation-score {
                color: #c7ff8e;
                font-weight: 600;
            }
            .reputation-count {
                font-size: 10px;
                color: #555;
                letter-spacing: 0.05em;
            }

            /* Feedback stars on agent messages */
            .feedback-row {
                display: flex;
                align-items: center;
                gap: 4px;
                margin-top: 6px;
                padding: 2px 0;
            }
            .feedback-star {
                font-size: 14px;
                color: #333;
                cursor: pointer;
                background: none;
                border: none;
                padding: 0 1px;
                font-family: inherit;
                line-height: 1;
                transition: color 0.15s;
            }
            .feedback-star:hover,
            .feedback-star.active {
                color: #c7ff8e;
            }
            .feedback-star.filled {
                color: #c7ff8e;
            }
            .feedback-star:disabled {
                cursor: default;
                opacity: 0.4;
            }
            .feedback-label {
                font-size: 9px;
                color: #555;
                text-transform: uppercase;
                letter-spacing: 0.08em;
                margin-left: 4px;
            }
            .feedback-tx {
                display: inline-block;
                font-size: 9px;
                color: #c7ff8e;
                border: 1px solid #2a3f18;
                padding: 2px 8px;
                border-radius: 2px;
                letter-spacing: 0.05em;
                text-decoration: none;
            }
            a.feedback-tx:hover {
                color: #e0ffbf;
                border-color: #4a7a28;
            }

            /* Hero section (shown before first message) */
            .hero {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
                padding: 48px 28px 24px;
                gap: 12px;
            }
            .hero-name {
                font-size: 32px;
                font-weight: 700;
                color: #f0f0f0;
                line-height: 1.2;
                letter-spacing: -0.02em;
            }
            .hero-desc {
                font-size: 13px;
                color: #666;
                line-height: 1.6;
                max-width: 480px;
            }

            /* Suggestion prompts */
            .suggestions {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
                padding: 8px 28px 0;
            }
            .suggestion-btn {
                font-size: 11px;
                color: #888;
                background: transparent;
                border: 1px dashed #2a2a2a;
                padding: 8px 16px;
                border-radius: 2px;
                cursor: pointer;
                font-family: inherit;
                transition: all 0.15s;
                text-align: left;
                max-width: 280px;
                letter-spacing: 0.01em;
            }
            .suggestion-btn:hover {
                color: #f0f0f0;
                border-color: #555;
                border-style: solid;
            }

            /* Messages area */
            #messages {
                flex: 1;
                overflow-y: auto;
                padding: 24px 28px;
                display: flex;
                flex-direction: column;
                gap: 14px;
            }
            .message {
                max-width: 640px;
                line-height: 1.6;
                font-size: 13px;
                white-space: pre-wrap;
                word-break: break-word;
            }
            .message.user {
                align-self: flex-end;
                background: #161616;
                border: 1px solid #2a2a2a;
                padding: 10px 14px;
                border-radius: 6px 6px 2px 6px;
                color: #e8e8e8;
            }
            .message.agent {
                align-self: flex-start;
                background: #111;
                border: 1px solid #1e1e1e;
                padding: 10px 14px;
                border-radius: 6px 6px 6px 2px;
                color: #ccc;
            }
            .message.agent.md {
                white-space: normal;
            }
            .message.agent.md p {
                margin: 0 0 0.6em;
            }
            .message.agent.md p:last-child {
                margin-bottom: 0;
            }
            .message.agent.md h1,
            .message.agent.md h2,
            .message.agent.md h3,
            .message.agent.md h4 {
                margin: 0.8em 0 0.3em;
                color: #e8e8e8;
                line-height: 1.3;
            }
            .message.agent.md h1 {
                font-size: 15px;
            }
            .message.agent.md h2 {
                font-size: 14px;
            }
            .message.agent.md h3 {
                font-size: 13px;
            }
            .message.agent.md h4 {
                font-size: 12px;
            }
            .message.agent.md h1:first-child,
            .message.agent.md h2:first-child,
            .message.agent.md h3:first-child {
                margin-top: 0;
            }
            .message.agent.md code {
                background: #1a1a1a;
                border: 1px solid #2a2a2a;
                padding: 1px 5px;
                border-radius: 3px;
                font-size: 12px;
            }
            .message.agent.md pre {
                background: #0d0d0d;
                border: 1px solid #222;
                border-radius: 4px;
                padding: 10px 12px;
                overflow-x: auto;
                margin: 0.5em 0;
            }
            .message.agent.md pre code {
                background: none;
                border: none;
                padding: 0;
                font-size: 12px;
                color: #b5b5b5;
            }
            .message.agent.md ul,
            .message.agent.md ol {
                margin: 0.4em 0;
                padding-left: 1.4em;
            }
            .message.agent.md li {
                margin: 0.15em 0;
            }
            .message.agent.md blockquote {
                border-left: 2px solid #333;
                margin: 0.5em 0;
                padding: 2px 0 2px 12px;
                color: #888;
            }
            .message.agent.md a {
                color: #c7ff8e;
                text-decoration: none;
            }
            .message.agent.md a:hover {
                text-decoration: underline;
            }
            .message.agent.md table {
                border-collapse: collapse;
                margin: 0.5em 0;
                font-size: 12px;
            }
            .message.agent.md th,
            .message.agent.md td {
                border: 1px solid #2a2a2a;
                padding: 4px 8px;
            }
            .message.agent.md th {
                background: #1a1a1a;
                color: #e8e8e8;
            }
            .message.agent.md hr {
                border: none;
                border-top: 1px solid #222;
                margin: 0.8em 0;
            }
            .message.system {
                align-self: center;
                color: #555;
                font-size: 11px;
                font-style: italic;
                letter-spacing: 0.02em;
            }
            .message.error {
                align-self: center;
                color: #e05555;
                font-size: 11px;
            }
            .message .payment-tag {
                display: inline-block;
                font-size: 9px;
                color: #c7ff8e;
                border: 1px solid #2a3f18;
                padding: 2px 8px;
                border-radius: 2px;
                margin-top: 6px;
                letter-spacing: 0.05em;
                text-decoration: none;
            }
            a.payment-tag:hover {
                color: #e0ffbf;
                border-color: #4a7a28;
                text-decoration: underline;
            }
            .message.status {
                align-self: flex-start;
                color: #666;
                font-size: 11px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            @keyframes pulse {
                0%,
                100% {
                    opacity: 0.3;
                }
                50% {
                    opacity: 1;
                }
            }
            .status-dot {
                width: 5px;
                height: 5px;
                border-radius: 50%;
                background: #c7ff8e;
                animation: pulse 1.4s ease-in-out infinite;
            }

            /* Input bar */
            #input-bar {
                padding: 16px 28px;
                border-top: 1px solid #1e1e1e;
                display: flex;
                gap: 10px;
                flex-shrink: 0;
                background: rgba(12, 12, 12, 0.9);
                backdrop-filter: blur(12px);
            }
            #input-bar input {
                flex: 1;
                background: #111;
                border: 1px solid #2a2a2a;
                color: #d4d4d4;
                padding: 10px 14px;
                border-radius: 4px;
                font-size: 13px;
                font-family: inherit;
                outline: none;
                transition: border-color 0.15s;
            }
            #input-bar input::placeholder {
                color: #444;
            }
            #input-bar input:focus {
                border-color: #555;
            }
            #input-bar input:disabled {
                opacity: 0.3;
            }

            /* Buttons */
            .btn-primary {
                background: #f0f0f0;
                color: #0c0c0c;
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 600;
                font-family: inherit;
                cursor: pointer;
                transition: background 0.15s;
                letter-spacing: 0.03em;
                text-transform: uppercase;
            }
            .btn-primary:hover {
                background: #fff;
            }
            .btn-primary:disabled {
                opacity: 0.3;
                cursor: default;
            }

            .btn-wallet {
                padding: 6px 14px;
                border-radius: 3px;
                border: 1px solid #333;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.15s;
                letter-spacing: 0.02em;
            }
            .btn-evm {
                background: #c7ff8e;
                color: #0c0c0c;
                border-color: #c7ff8e;
                font-weight: 600;
            }
            .btn-evm:hover {
                background: #b5f070;
            }
            .btn-phantom {
                background: #ab9ff2;
                color: #0c0c0c;
                border-color: #ab9ff2;
                font-weight: 600;
            }
            .btn-phantom:hover {
                background: #9a8de0;
            }
            .btn-disconnect {
                background: transparent;
                color: #555;
                display: none;
            }
            .btn-disconnect:hover {
                color: #d4d4d4;
                border-color: #555;
            }
            .btn-wallet:disabled {
                opacity: 0.4;
                cursor: default;
            }

            .hidden {
                display: none !important;
            }
        </style>
    </head>
    <body>
        <header>
            <div class="agent-meta">
                <span class="agent-name" id="agent-name">Loading...</span>
                <span class="agent-version hidden" id="agent-version"></span>
            </div>
            <div class="wallet-area hidden" id="wallet-area">
                <span class="wallet-info" id="wallet-info"></span>
                <button class="btn-wallet btn-evm" id="connect-evm">
                    Connect MetaMask
                </button>
                <button class="btn-wallet btn-disconnect" id="disconnect-evm">
                    Disconnect EVM
                </button>
                <span class="phantom-info" id="phantom-info"></span>
                <button class="btn-wallet btn-phantom" id="connect-phantom">
                    Connect Phantom
                </button>
                <button
                    class="btn-wallet btn-disconnect"
                    id="disconnect-phantom"
                >
                    Disconnect SOL
                </button>
            </div>
        </header>

        <div class="info-bar" id="info-bar">
            <div class="agent-description" id="agent-description"></div>
            <div class="capabilities-row" id="capabilities-row"></div>

            <div class="reputation-row hidden" id="reputation-row"></div>
            <div class="provider-row hidden" id="provider-row"></div>
        </div>

        <div id="messages">
            <div class="hero" id="hero">
                <div class="hero-name" id="hero-name"></div>
                <div class="hero-desc" id="hero-desc"></div>
            </div>
            <div class="message system" id="welcome-msg">
                Loading agent info...
            </div>
            <div class="suggestions" id="suggestions"></div>
        </div>

        <div id="input-bar">
            <input
                id="chat-input"
                type="text"
                placeholder="Type a message..."
                disabled
            />
            <button class="btn-primary" id="send-btn" disabled>Send</button>
        </div>

        <script type="module">
            // -----------------------------------------------------------------------
            // State
            // -----------------------------------------------------------------------
            let contextId = null;
            let agentCard = null;
            let activeStatus = null;

            // x402 payment state (lazy-loaded)
            let x402Client = null;
            let wrapFetchWithPayment = null;
            let evmWalletClient = null;
            let phantomPublicKey = null;
            let x402Loaded = false;
            let x402Loading = false;

            // -----------------------------------------------------------------------
            // DOM references
            // -----------------------------------------------------------------------
            const $ = (id) => document.getElementById(id);
            const agentNameEl = $("agent-name");
            const agentVersionEl = $("agent-version");
            const agentDescEl = $("agent-description");
            const capsRowEl = $("capabilities-row");

            const providerRowEl = $("provider-row");
            const suggestionsEl = $("suggestions");
            const heroEl = $("hero");
            const heroNameEl = $("hero-name");
            const heroDescEl = $("hero-desc");
            const walletArea = $("wallet-area");
            const walletInfoEl = $("wallet-info");
            const phantomInfoEl = $("phantom-info");
            const connectEvmBtn = $("connect-evm");
            const disconnectEvmBtn = $("disconnect-evm");
            const connectPhantomBtn = $("connect-phantom");
            const disconnectPhantomBtn = $("disconnect-phantom");
            const messagesDiv = $("messages");
            const welcomeMsg = $("welcome-msg");
            const chatInput = $("chat-input");
            const sendBtn = $("send-btn");

            // -----------------------------------------------------------------------
            // Agent card fetch
            // -----------------------------------------------------------------------
            async function loadAgentCard() {
                try {
                    const res = await fetch("/.well-known/agent-card.json");
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    agentCard = await res.json();

                    // Populate header
                    agentNameEl.textContent = agentCard.name || "Agent";
                    document.title = agentCard.name || "Agent";

                    if (agentCard.image) {
                        const link = document.createElement("link");
                        link.rel = "icon";
                        link.href = agentCard.image;
                        document.head.appendChild(link);
                    }

                    if (agentCard.version) {
                        agentVersionEl.textContent = `v${agentCard.version}`;
                        agentVersionEl.classList.remove("hidden");
                    }

                    // Hero section
                    heroNameEl.textContent = agentCard.name || "Agent";
                    heroDescEl.textContent = agentCard.description || "";

                    // Description in info bar
                    agentDescEl.textContent = agentCard.description || "";

                    // Capabilities badges
                    const caps = agentCard.capabilities || {};
                    capsRowEl.innerHTML = "";
                    if (caps.streaming) addBadge(capsRowEl, "streaming");
                    if (caps.multiTurn) addBadge(capsRowEl, "multi-turn");
                    if (caps.pushNotifications)
                        addBadge(capsRowEl, "push notifications");

                    // Skills display removed (OASF tags are not user-friendly)

                    // Provider attribution
                    const provider = agentCard.provider;
                    if (provider && provider.organization) {
                        providerRowEl.classList.remove("hidden");
                        if (provider.url) {
                            providerRowEl.innerHTML = `by <a href="${escAttr(provider.url)}" target="_blank" rel="noopener">${esc(provider.organization)}</a>`;
                        } else {
                            providerRowEl.textContent = `by ${provider.organization}`;
                        }
                    }

                    // Example prompts as conversation starters
                    const examples = (agentCard.skills || []).flatMap((s) =>
                        (s.examples || []).slice(0, 2),
                    );
                    suggestionsEl.innerHTML = "";
                    for (const ex of examples.slice(0, 4)) {
                        const btn = document.createElement("button");
                        btn.className = "suggestion-btn";
                        btn.textContent = ex;
                        btn.addEventListener("click", () => {
                            suggestionsEl.remove();
                            sendMessage(ex);
                        });
                        suggestionsEl.appendChild(btn);
                    }

                    // Enable chat
                    chatInput.disabled = false;
                    sendBtn.disabled = false;
                    chatInput.focus();
                    welcomeMsg.textContent =
                        "Send a message to start chatting.";

                    // Check agent-registration.json for x402 support;
                    // if enabled, load payment libraries eagerly so wallet
                    // buttons are visible before the user sends a message.
                    try {
                        const regRes = await fetch("/agent-registration.json");
                        if (regRes.ok) {
                            const reg = await regRes.json();
                            if (reg.x402Support) {
                                await loadX402(reg.x402Networks);
                                welcomeMsg.textContent =
                                    "Connect a wallet, then send a message.";
                            }

                            // Parse on-chain registrations for reputation
                            if (Array.isArray(reg.registrations)) {
                                for (const r of reg.registrations) {
                                    if (!r.agentId || !r.agentRegistry)
                                        continue;
                                    // agentRegistry format: "eip155:{chainId}:{address}"
                                    const parts = r.agentRegistry.split(":");
                                    if (parts.length < 2) continue;
                                    const chainId = parseInt(parts[1], 10);
                                    if (isNaN(chainId)) continue;
                                    agentRegistrations.push({
                                        chainId,
                                        agentId: BigInt(r.agentId),
                                        identityRegistry: parts[2] || null,
                                        isMainnet:
                                            MAINNET_CHAIN_IDS.has(chainId),
                                    });
                                }
                            }
                            if (agentRegistrations.length > 0) {
                                // Show wallet area for reputation (EVM only)
                                if (!reg.x402Support) {
                                    walletArea.classList.remove("hidden");
                                    connectPhantomBtn.classList.add("hidden");
                                    welcomeMsg.textContent =
                                        "Send a message to start chatting. Connect a wallet to leave feedback.";
                                }
                                loadReputation();
                            }
                        }
                    } catch {}
                } catch (err) {
                    welcomeMsg.textContent =
                        "Could not load agent card. Is the agent running?";
                    welcomeMsg.className = "message error";
                }
            }

            function addBadge(container, label) {
                const span = document.createElement("span");
                span.className = "cap-badge";
                span.textContent = label;
                container.appendChild(span);
            }

            function esc(str) {
                const d = document.createElement("div");
                d.textContent = str;
                return d.innerHTML;
            }

            function escAttr(str) {
                return str
                    .replace(/&/g, "&amp;")
                    .replace(/"/g, "&quot;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }

            // -----------------------------------------------------------------------
            // Block explorer URLs by CAIP-2 network identifier
            // -----------------------------------------------------------------------
            const BLOCK_EXPLORERS = {
                "eip155:1": "https://etherscan.io/tx/",
                "eip155:11155111": "https://sepolia.etherscan.io/tx/",
                "eip155:8453": "https://basescan.org/tx/",
                "eip155:84532": "https://sepolia.basescan.org/tx/",
                "eip155:42161": "https://arbiscan.io/tx/",
                "eip155:421614": "https://sepolia.arbiscan.io/tx/",
                "eip155:10": "https://optimistic.etherscan.io/tx/",
                "eip155:11155420": "https://sepolia-optimism.etherscan.io/tx/",
                "eip155:137": "https://polygonscan.com/tx/",
                "eip155:80002": "https://amoy.polygonscan.com/tx/",
                "solana:mainnet": "https://solscan.io/tx/",
                "solana:devnet": "https://solscan.io/tx/?cluster=devnet",
            };

            // -----------------------------------------------------------------------
            // ERC-8004 Reputation Registry constants
            // -----------------------------------------------------------------------
            const PUBLIC_RPCS = {
                "eip155:1": "https://eth.drpc.org",
                "eip155:8453": "https://mainnet.base.org",
                "eip155:42161": "https://arb1.arbitrum.io/rpc",
                "eip155:10": "https://mainnet.optimism.io",
                "eip155:11155111": "https://sepolia.drpc.org",
                "eip155:84532": "https://sepolia.base.org",
            };

            const REPUTATION_REGISTRY = {
                mainnet: "0x8004BAa17C55a88189AE136b182e5fdA19dE9b63",
                testnet: "0x8004B663056A597Dffe9eCcC1965A193B7388713",
            };

            const MAINNET_CHAIN_IDS = new Set([1, 8453, 42161, 10, 137]);

            // Lower rank = cheaper gas. L2s first, L1 last.
            const CHAIN_COST_RANK = {
                8453: 0, // Base
                84532: 0, // Base Sepolia
                10: 1, // Optimism
                42161: 1, // Arbitrum
                137: 2, // Polygon
                11155111: 3, // Sepolia (testnet L1)
                1: 4, // Ethereum mainnet
            };

            const REPUTATION_ABI = [
                {
                    name: "giveFeedback",
                    type: "function",
                    stateMutability: "nonpayable",
                    inputs: [
                        { name: "agentId", type: "uint256" },
                        { name: "value", type: "int128" },
                        { name: "valueDecimals", type: "uint8" },
                        { name: "tag1", type: "string" },
                        { name: "tag2", type: "string" },
                        { name: "endpoint", type: "string" },
                        { name: "feedbackURI", type: "string" },
                        { name: "feedbackHash", type: "bytes32" },
                    ],
                    outputs: [],
                },
                {
                    name: "getSummary",
                    type: "function",
                    stateMutability: "view",
                    inputs: [
                        { name: "agentId", type: "uint256" },
                        { name: "clientAddresses", type: "address[]" },
                        { name: "tag1", type: "string" },
                        { name: "tag2", type: "string" },
                    ],
                    outputs: [
                        { name: "count", type: "uint64" },
                        { name: "summaryValue", type: "int128" },
                        { name: "summaryValueDecimals", type: "uint8" },
                    ],
                },
                {
                    name: "getClients",
                    type: "function",
                    stateMutability: "view",
                    inputs: [{ name: "agentId", type: "uint256" }],
                    outputs: [{ name: "", type: "address[]" }],
                },
            ];

            const IDENTITY_ABI = [
                {
                    name: "isAuthorizedOrOwner",
                    type: "function",
                    stateMutability: "view",
                    inputs: [
                        { name: "spender", type: "address" },
                        { name: "agentId", type: "uint256" },
                    ],
                    outputs: [{ name: "", type: "bool" }],
                },
            ];

            let agentRegistrations = [];
            let reputationScore = null;
            let reputationLoaded = false;

            // -----------------------------------------------------------------------
            // Message display helpers
            // -----------------------------------------------------------------------
            function appendMessage(text, kind, payment) {
                // Remove hero on first real message
                if (heroEl.parentNode) heroEl.remove();

                const div = document.createElement("div");
                div.className = `message ${kind}`;
                // Use a content span so we can upgrade to markdown without
                // losing sibling elements (payment tag, feedback row)
                const content = document.createElement("span");
                content.textContent = text;
                div.appendChild(content);
                // Render markdown for agent messages (async, progressive)
                if (kind === "agent") {
                    renderMarkdown(text).then((html) => {
                        if (!html) return;
                        div.classList.add("md");
                        content.innerHTML = html;
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    });
                }
                if (payment?.transaction) {
                    const explorerBase =
                        BLOCK_EXPLORERS[payment.network] ||
                        (evmChainId &&
                            BLOCK_EXPLORERS[`eip155:${evmChainId}`]) ||
                        null;
                    div.appendChild(document.createElement("br"));
                    if (explorerBase) {
                        const link = document.createElement("a");
                        link.className = "payment-tag";
                        link.href = explorerBase + payment.transaction;
                        link.target = "_blank";
                        link.rel = "noopener";
                        link.textContent = `paid: ${payment.transaction}`;
                        div.appendChild(link);
                    } else {
                        const tag = document.createElement("span");
                        tag.className = "payment-tag";
                        tag.textContent = `paid: ${payment.transaction}`;
                        div.appendChild(tag);
                    }
                }
                // Append feedback stars to agent messages when registered
                if (kind === "agent" && agentRegistrations.length > 0) {
                    div.appendChild(createFeedbackRow());
                }

                messagesDiv.appendChild(div);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }

            function showStatus(text) {
                const div = document.createElement("div");
                div.className = "message status";
                const dot = document.createElement("span");
                dot.className = "status-dot";
                div.appendChild(dot);
                const span = document.createElement("span");
                span.textContent = text;
                div.appendChild(span);
                messagesDiv.appendChild(div);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                return div;
            }

            function updateStatus(el, text) {
                const span = el.querySelector("span:last-child");
                if (span) span.textContent = text;
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }

            function removeStatus(el) {
                el.remove();
            }

            // -----------------------------------------------------------------------
            // Viem loader (shared by x402 payments and reputation)
            // -----------------------------------------------------------------------
            async function ensureViem() {
                if (viemModule) return viemModule;
                viemModule = await import("https://esm.sh/viem@2?bundle");
                return viemModule;
            }

            // -----------------------------------------------------------------------
            // Markdown renderer (lazy-loaded from CDN)
            // -----------------------------------------------------------------------
            async function ensureMarked() {
                if (markedModule) return markedModule;
                markedModule = await import("https://esm.sh/marked@15?bundle");
                markedModule.marked.setOptions({ breaks: true, gfm: true });
                return markedModule;
            }

            function sanitizeHtml(html) {
                const el = document.createElement("div");
                el.innerHTML = html;
                el.querySelectorAll("script,iframe,object,embed,form").forEach(
                    (n) => n.remove(),
                );
                el.querySelectorAll("*").forEach((n) => {
                    for (const attr of [...n.attributes]) {
                        if (
                            attr.name.startsWith("on") ||
                            (attr.name === "href" &&
                                attr.value
                                    .trimStart()
                                    .startsWith("javascript:"))
                        ) {
                            n.removeAttribute(attr.name);
                        }
                    }
                });
                // Open all links in new tab
                el.querySelectorAll("a").forEach((a) => {
                    a.setAttribute("target", "_blank");
                    a.setAttribute("rel", "noopener");
                });
                return el.innerHTML;
            }

            async function renderMarkdown(text) {
                try {
                    const m = await ensureMarked();
                    const raw = await m.marked.parse(text);
                    return sanitizeHtml(raw);
                } catch {
                    return null;
                }
            }

            // -----------------------------------------------------------------------
            // x402 payment support (lazy-loaded from CDN)
            // -----------------------------------------------------------------------
            async function loadX402(networks) {
                if (x402Loaded || x402Loading) return x402Loaded;
                x402Loading = true;

                // Determine which wallet families to show.
                // If no networks array provided (lazy 402 fallback), show all.
                const showEvm =
                    !networks ||
                    networks.length === 0 ||
                    networks.includes("evm");
                const showSolana =
                    !networks ||
                    networks.length === 0 ||
                    networks.includes("solana");

                try {
                    const [fetchMod, evmMod] = await Promise.all([
                        import("https://esm.sh/@x402/fetch@2?bundle"),
                        import(
                            "https://esm.sh/@x402/evm@2/exact/client?bundle"
                        ),
                    ]);

                    wrapFetchWithPayment = fetchMod.wrapFetchWithPayment;
                    const { x402Client: X402Client, registerExactEvmScheme } =
                        fetchMod;
                    const evmRegister = evmMod.registerExactEvmScheme;

                    // Store references for wallet setup
                    window.__x402 = {
                        X402Client,
                        registerExactEvmScheme: evmRegister,
                        wrapFetchWithPayment,
                    };
                    x402Loaded = true;

                    // Show only relevant wallet buttons
                    walletArea.classList.remove("hidden");
                    if (!showEvm) {
                        connectEvmBtn.classList.add("hidden");
                    }
                    if (!showSolana) {
                        connectPhantomBtn.classList.add("hidden");
                    }
                    const x4 = agentCard?.x402;
                    const priceInfo =
                        x4?.price && x4?.currency
                            ? ` (${x4.price} ${x4.currency} per request)`
                            : "";
                    appendMessage(
                        `This agent requires payment${priceInfo}.`,
                        "system",
                    );
                } catch (err) {
                    appendMessage(
                        `Failed to load payment libraries: ${err.message}`,
                        "error",
                    );
                } finally {
                    x402Loading = false;
                }
                return x402Loaded;
            }

            // -----------------------------------------------------------------------
            // Wallet: MetaMask (EVM)
            // -----------------------------------------------------------------------
            function hasAnyWallet() {
                return evmWalletClient !== null || phantomPublicKey !== null;
            }

            // Current EVM chain ID (decimal), kept in sync with MetaMask
            let evmChainId = null;
            // Cached viem module so we can recreate the wallet client on chain change
            let viemModule = null;
            // Cached marked module for markdown rendering
            let markedModule = null;

            function rebuildEvmWalletClient(chainId) {
                if (!viemModule || !evmWalletClient) return;
                evmChainId = chainId;
                evmWalletClient = viemModule.createWalletClient({
                    account: evmWalletClient.account.address,
                    chain: { id: chainId },
                    transport: viemModule.custom(window.ethereum),
                });
            }

            async function connectEvm() {
                const ethereum = window.ethereum;
                if (!ethereum) {
                    appendMessage(
                        "MetaMask not detected. Install it to continue.",
                        "error",
                    );
                    return;
                }
                try {
                    connectEvmBtn.disabled = true;
                    const accounts = await ethereum.request({
                        method: "eth_requestAccounts",
                    });
                    const address = accounts[0];

                    // Read the currently selected chain
                    const hexChainId = await ethereum.request({
                        method: "eth_chainId",
                    });
                    evmChainId = parseInt(hexChainId, 16);

                    // Dynamic import viem only when needed
                    if (!viemModule) {
                        viemModule = await import(
                            "https://esm.sh/viem@2?bundle"
                        );
                    }
                    evmWalletClient = viemModule.createWalletClient({
                        account: address,
                        chain: { id: evmChainId },
                        transport: viemModule.custom(ethereum),
                    });

                    const short = `${address.slice(0, 6)}...${address.slice(-4)}`;
                    walletInfoEl.textContent = short;
                    connectEvmBtn.style.display = "none";
                    disconnectEvmBtn.style.display = "inline-block";
                    appendMessage(`EVM wallet connected: ${short}`, "system");
                    refreshFeedbackRows();
                } catch (err) {
                    appendMessage(
                        `Connection failed: ${err.message || err}`,
                        "error",
                    );
                } finally {
                    connectEvmBtn.disabled = false;
                }
            }

            function disconnectEvm() {
                evmWalletClient = null;
                evmChainId = null;
                walletInfoEl.textContent = "";
                connectEvmBtn.style.display = "inline-block";
                disconnectEvmBtn.style.display = "none";
                appendMessage("EVM wallet disconnected.", "system");
                refreshFeedbackRows();
            }

            // -----------------------------------------------------------------------
            // Wallet: Phantom (Solana)
            // -----------------------------------------------------------------------
            async function connectPhantom() {
                const phantom = window.phantom?.solana;
                if (!phantom?.isPhantom) {
                    appendMessage(
                        "Phantom not detected. Install it from phantom.app.",
                        "error",
                    );
                    return;
                }
                try {
                    connectPhantomBtn.disabled = true;
                    const resp = await phantom.connect();
                    phantomPublicKey = resp.publicKey.toBase58();
                    const short = `${phantomPublicKey.slice(0, 4)}...${phantomPublicKey.slice(-4)}`;
                    phantomInfoEl.textContent = short;
                    connectPhantomBtn.style.display = "none";
                    disconnectPhantomBtn.style.display = "inline-block";
                    appendMessage(
                        `Solana wallet connected: ${short}`,
                        "system",
                    );
                } catch (err) {
                    appendMessage(
                        `Phantom connection failed: ${err.message || err}`,
                        "error",
                    );
                } finally {
                    connectPhantomBtn.disabled = false;
                }
            }

            function disconnectPhantom() {
                const phantom = window.phantom?.solana;
                if (phantom)
                    try {
                        phantom.disconnect();
                    } catch {}
                phantomPublicKey = null;
                phantomInfoEl.textContent = "";
                connectPhantomBtn.style.display = "inline-block";
                disconnectPhantomBtn.style.display = "none";
                appendMessage("Solana wallet disconnected.", "system");
            }

            // -----------------------------------------------------------------------
            // Build x402-wrapped fetch (when wallets are connected)
            // -----------------------------------------------------------------------
            function buildPaymentFetch() {
                if (!x402Loaded || !window.__x402) return null;
                if (!hasAnyWallet()) return null;

                const {
                    X402Client,
                    registerExactEvmScheme,
                    wrapFetchWithPayment,
                } = window.__x402;

                const client = new X402Client((_version, accepts) => {
                    // 1. Try the currently selected MetaMask chain
                    if (evmWalletClient && evmChainId) {
                        const currentNet = `eip155:${evmChainId}`;
                        const match = accepts.find(
                            (a) => a.network === currentNet,
                        );
                        if (match) return match;
                    }

                    // 2. Try Solana
                    if (phantomPublicKey) {
                        const solMatch = accepts.find((a) =>
                            a.network.startsWith("solana:"),
                        );
                        if (solMatch) return solMatch;
                    }

                    // 3. First available
                    return accepts[0];
                });

                if (evmWalletClient) {
                    const signer = {
                        address: evmWalletClient.account.address,
                        signTypedData: async (message) => {
                            // The domain contains the chain the payment targets.
                            // If it differs from the wallet client's chain, switch
                            // MetaMask and rebuild the client before signing.
                            const requiredChain = Number(
                                message.domain?.chainId,
                            );
                            if (requiredChain && requiredChain !== evmChainId) {
                                const hexChain = `0x${requiredChain.toString(16)}`;
                                await window.ethereum.request({
                                    method: "wallet_switchEthereumChain",
                                    params: [{ chainId: hexChain }],
                                });
                                rebuildEvmWalletClient(requiredChain);
                            }
                            return evmWalletClient.signTypedData({
                                account: evmWalletClient.account,
                                domain: message.domain,
                                types: message.types,
                                primaryType: message.primaryType,
                                message: message.message,
                            });
                        },
                    };
                    registerExactEvmScheme(client, { signer });
                }

                // Create instrumented fetch that reports payment flow
                let sawPaymentRequired = false;
                const instrumented = async (input, init) => {
                    const res = await fetch(input, init);
                    if (res.status === 402 && !sawPaymentRequired) {
                        sawPaymentRequired = true;
                        if (activeStatus)
                            updateStatus(
                                activeStatus,
                                "Agent requires payment. Signing...",
                            );
                        return res;
                    }
                    if (sawPaymentRequired) {
                        sawPaymentRequired = false;
                        if (activeStatus)
                            updateStatus(
                                activeStatus,
                                "Payment sent. Waiting for response...",
                            );
                    }
                    return res;
                };

                return wrapFetchWithPayment(instrumented, client);
            }

            // -----------------------------------------------------------------------
            // ERC-8004 Reputation: display + feedback
            // -----------------------------------------------------------------------
            function getMatchingRegistration() {
                if (!evmWalletClient || !evmChainId) return null;
                return (
                    agentRegistrations.find((r) => r.chainId === evmChainId) ||
                    null
                );
            }

            function getCheapestRegistration() {
                if (agentRegistrations.length === 0) return null;
                return agentRegistrations.reduce((best, r) => {
                    const bestRank = CHAIN_COST_RANK[best.chainId] ?? 99;
                    const rRank = CHAIN_COST_RANK[r.chainId] ?? 99;
                    return rRank < bestRank ? r : best;
                });
            }

            async function loadReputation() {
                if (agentRegistrations.length === 0) return;
                try {
                    const viem = await ensureViem();
                    const results = await Promise.allSettled(
                        agentRegistrations.map(async (reg) => {
                            const rpcUrl = PUBLIC_RPCS[`eip155:${reg.chainId}`];
                            if (!rpcUrl) return null;
                            const addr = reg.isMainnet
                                ? REPUTATION_REGISTRY.mainnet
                                : REPUTATION_REGISTRY.testnet;
                            const client = viem.createPublicClient({
                                transport: viem.http(rpcUrl),
                            });
                            const clients = await client.readContract({
                                address: addr,
                                abi: REPUTATION_ABI,
                                functionName: "getClients",
                                args: [reg.agentId],
                            });
                            if (!clients || clients.length === 0)
                                return { count: 0n, value: 0n };
                            const [count, summaryValue] =
                                await client.readContract({
                                    address: addr,
                                    abi: REPUTATION_ABI,
                                    functionName: "getSummary",
                                    args: [reg.agentId, clients, "", ""],
                                });
                            return { count, value: summaryValue };
                        }),
                    );
                    let totalCount = 0n;
                    let weightedSum = 0n;
                    for (const r of results) {
                        if (r.status !== "fulfilled" || !r.value) continue;
                        const { count, value } = r.value;
                        totalCount += BigInt(count);
                        weightedSum += BigInt(value) * BigInt(count);
                    }
                    const countNum = Number(totalCount);
                    const average =
                        countNum > 0 ? Number(weightedSum / totalCount) : 0;
                    reputationScore = { count: countNum, average };
                    reputationLoaded = true;
                    renderReputation();
                } catch (err) {
                    console.warn("Failed to load reputation:", err);
                }
            }

            function renderReputation() {
                const row = $("reputation-row");
                if (!reputationScore || reputationScore.count === 0) {
                    row.innerHTML =
                        '<span class="reputation-count">no feedback yet</span>';
                    row.classList.remove("hidden");
                    return;
                }
                const { count, average } = reputationScore;
                const displayScore = Math.round(average);
                const starCount = Math.round(average / 20);
                let starsHtml = "";
                for (let i = 1; i <= 5; i++) {
                    starsHtml += i <= starCount ? "\u2605" : "\u2606";
                }
                row.innerHTML = `<span class="reputation-badge"><span class="reputation-score">${starsHtml} ${displayScore}/100</span></span><span class="reputation-count">${count} review${count !== 1 ? "s" : ""} on-chain</span>`;
                row.classList.remove("hidden");
            }

            function createFeedbackRow() {
                const row = document.createElement("div");
                row.className = "feedback-row";
                const canSubmit =
                    evmWalletClient && agentRegistrations.length > 0;
                for (let i = 1; i <= 5; i++) {
                    const star = document.createElement("button");
                    star.className = "feedback-star";
                    star.dataset.star = i;
                    star.textContent = "\u2606";
                    star.disabled = !canSubmit;
                    star.title = canSubmit
                        ? `Rate ${i * 20}/100`
                        : "Connect wallet to rate";
                    if (canSubmit) {
                        star.addEventListener("click", () =>
                            submitFeedback(row, i),
                        );
                    }
                    row.appendChild(star);
                }
                if (canSubmit) {
                    row.addEventListener("mouseover", (e) => {
                        if (row.dataset.submitted) return;
                        const target = e.target.closest(".feedback-star");
                        if (!target) return;
                        const hovered = parseInt(target.dataset.star, 10);
                        row.querySelectorAll(".feedback-star").forEach((s) => {
                            const active =
                                parseInt(s.dataset.star, 10) <= hovered;
                            s.textContent = active ? "\u2605" : "\u2606";
                            s.classList.toggle("filled", active);
                        });
                    });
                    row.addEventListener("mouseleave", () => {
                        if (row.dataset.submitted) return;
                        row.querySelectorAll(".feedback-star").forEach((s) => {
                            s.textContent = "\u2606";
                            s.classList.remove("filled");
                        });
                    });
                }
                const label = document.createElement("span");
                label.className = "feedback-label";
                label.textContent = canSubmit
                    ? "rate this response"
                    : "connect wallet to rate";
                row.appendChild(label);
                return row;
            }

            async function submitFeedback(row, stars) {
                if (!evmWalletClient) return;
                if (row.dataset.submitted) return;

                // Pick the cheapest chain, auto-switch if needed
                const reg = getCheapestRegistration();
                if (!reg) return;

                const starBtns = row.querySelectorAll(".feedback-star");
                starBtns.forEach((s, idx) => {
                    s.disabled = true;
                    const filled = idx < stars;
                    s.textContent = filled ? "\u2605" : "\u2606";
                    s.classList.toggle("filled", filled);
                });
                row.dataset.submitted = "true";
                const label = row.querySelector(".feedback-label");

                if (reg.chainId !== evmChainId) {
                    label.textContent = "switching chain...";
                    try {
                        await window.ethereum.request({
                            method: "wallet_switchEthereumChain",
                            params: [
                                { chainId: "0x" + reg.chainId.toString(16) },
                            ],
                        });
                        rebuildEvmWalletClient(reg.chainId);
                    } catch (switchErr) {
                        label.textContent = "chain switch rejected";
                        row.dataset.submitted = "";
                        starBtns.forEach((s) => {
                            s.disabled = false;
                        });
                        return;
                    }
                }

                label.textContent = "submitting...";

                const addr = reg.isMainnet
                    ? REPUTATION_REGISTRY.mainnet
                    : REPUTATION_REGISTRY.testnet;

                try {
                    // Pre-flight: check if caller is agent owner (free view call)
                    if (reg.identityRegistry) {
                        const rpcUrl = PUBLIC_RPCS[`eip155:${reg.chainId}`];
                        if (rpcUrl) {
                            const viem = await ensureViem();
                            const pub = viem.createPublicClient({
                                transport: viem.http(rpcUrl),
                            });
                            const isOwner = await pub.readContract({
                                address: reg.identityRegistry,
                                abi: IDENTITY_ABI,
                                functionName: "isAuthorizedOrOwner",
                                args: [
                                    evmWalletClient.account.address,
                                    reg.agentId,
                                ],
                            });
                            if (isOwner) {
                                label.textContent = "cannot rate own agent";
                                return;
                            }
                        }
                    }

                    const hash = await evmWalletClient.writeContract({
                        address: addr,
                        abi: REPUTATION_ABI,
                        functionName: "giveFeedback",
                        args: [
                            reg.agentId,
                            BigInt(stars * 20),
                            0,
                            "starred",
                            "",
                            window.location.origin,
                            "",
                            "0x0000000000000000000000000000000000000000000000000000000000000000",
                        ],
                    });
                    const explorerBase =
                        BLOCK_EXPLORERS[`eip155:${reg.chainId}`];
                    if (explorerBase) {
                        const link = document.createElement("a");
                        link.className = "feedback-tx";
                        link.href = explorerBase + hash;
                        link.target = "_blank";
                        link.rel = "noopener";
                        link.textContent = `tx: ${hash.slice(0, 10)}...`;
                        label.replaceWith(link);
                    } else {
                        label.className = "feedback-tx";
                        label.textContent = `tx: ${hash.slice(0, 10)}...`;
                    }
                    setTimeout(() => loadReputation(), 5000);
                } catch (err) {
                    const msg = err.message || String(err);
                    if (msg.includes("execution reverted")) {
                        label.textContent = "cannot rate own agent";
                    } else {
                        label.textContent = `failed: ${msg.slice(0, 60)}`;
                        row.dataset.submitted = "";
                        starBtns.forEach((s) => {
                            s.disabled = false;
                        });
                    }
                }
            }

            function refreshFeedbackRows() {
                const canSubmit =
                    evmWalletClient && agentRegistrations.length > 0;
                for (const row of document.querySelectorAll(".feedback-row")) {
                    if (row.dataset.submitted) continue;
                    row.querySelectorAll(".feedback-star").forEach((s) => {
                        s.disabled = !canSubmit;
                    });
                    const label = row.querySelector(".feedback-label");
                    if (label) {
                        label.textContent = canSubmit
                            ? "rate this response"
                            : "connect wallet to rate";
                    }
                }
            }

            // -----------------------------------------------------------------------
            // SSE stream reader
            // -----------------------------------------------------------------------
            async function readSSEStream(res) {
                const reader = res.body?.getReader();
                if (!reader) return [];

                const decoder = new TextDecoder();
                const isTextPart = (p) =>
                    p.kind === "text" || p.type === "text";
                const agentTexts = [];
                let buffer = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const messages = buffer.split("\n\n");
                    buffer = messages.pop() || "";

                    for (const msg of messages) {
                        const dataLines = msg
                            .split("\n")
                            .filter((line) => line.startsWith("data:"))
                            .map((line) => line.slice(5).trim());

                        if (dataLines.length === 0) continue;
                        const jsonStr = dataLines.join("");
                        if (!jsonStr) continue;

                        let event;
                        try {
                            event = JSON.parse(jsonStr);
                        } catch {
                            continue;
                        }

                        if (event.error) {
                            agentTexts.push(
                                `Error: ${event.error.message || JSON.stringify(event.error)}`,
                            );
                            return agentTexts;
                        }

                        const result = event.result;
                        if (!result) continue;

                        if (result.contextId) contextId = result.contextId;
                        if (result.context_id) contextId = result.context_id;

                        if (
                            result.status?.state === "working" &&
                            activeStatus
                        ) {
                            updateStatus(activeStatus, "Agent is working...");
                        }

                        if (
                            result.status?.state === "completed" &&
                            result.status.message
                        ) {
                            const parts = result.status.message.parts || [];
                            for (const p of parts) {
                                if (isTextPart(p) && p.text)
                                    agentTexts.push(p.text);
                            }
                        }

                        if (result.history) {
                            const texts = result.history
                                .filter((m) => m.role === "agent")
                                .flatMap((m) => m.parts)
                                .filter(isTextPart)
                                .map((p) => p.text);
                            agentTexts.push(...texts);
                        }

                        if (result.artifact?.parts) {
                            for (const p of result.artifact.parts) {
                                if (isTextPart(p) && p.text)
                                    agentTexts.push(p.text);
                            }
                        }
                    }
                }

                return agentTexts;
            }

            // -----------------------------------------------------------------------
            // Extract result from non-streaming JSON response
            // -----------------------------------------------------------------------
            function extractResult(result, payment) {
                if (result?.contextId) contextId = result.contextId;
                if (result?.context_id) contextId = result.context_id;

                const isTextPart = (p) =>
                    p.kind === "text" || p.type === "text";

                const historyTexts = (result?.history ?? [])
                    .filter((m) => m.role === "agent")
                    .flatMap((m) => m.parts)
                    .filter(isTextPart)
                    .map((p) => p.text);

                if (historyTexts.length > 0) {
                    appendMessage(historyTexts.join("\n"), "agent", payment);
                } else {
                    const artifactTexts = (result?.artifacts ?? [])
                        .flatMap((a) => a.parts)
                        .filter(isTextPart)
                        .map((p) => p.text);
                    appendMessage(
                        artifactTexts.join("\n") || "(no agent response)",
                        artifactTexts.length > 0 ? "agent" : "system",
                        payment,
                    );
                }
            }

            // -----------------------------------------------------------------------
            // Send message
            // -----------------------------------------------------------------------
            async function sendMessage(text) {
                // Remove suggestion buttons and hero on first message
                if (suggestionsEl.parentNode) suggestionsEl.remove();
                if (heroEl.parentNode) heroEl.remove();

                appendMessage(text, "user");
                chatInput.value = "";
                chatInput.disabled = true;
                sendBtn.disabled = true;

                activeStatus = showStatus("Sending to agent...");

                const rpcBody = {
                    jsonrpc: "2.0",
                    id: Date.now(),
                    method: "message/stream",
                    params: {
                        message: {
                            role: "user",
                            parts: [{ type: "text", text }],
                        },
                    },
                };
                if (contextId) rpcBody.params.contextId = contextId;

                // Use payment-wrapped fetch if available, otherwise plain fetch
                const requestFetch = buildPaymentFetch() || fetch;

                try {
                    const res = await requestFetch(
                        window.location.origin + "/",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(rpcBody),
                        },
                    );

                    // Detect x402 payment requirement
                    if (res.status === 402) {
                        removeStatus(activeStatus);
                        if (!x402Loaded) {
                            const loaded = await loadX402();
                            if (loaded) {
                                appendMessage(
                                    "Payment libraries loaded. Connect a wallet, then resend your message.",
                                    "system",
                                );
                            }
                        } else if (!hasAnyWallet()) {
                            appendMessage(
                                "Connect a wallet to pay for this request.",
                                "system",
                            );
                        } else {
                            appendMessage(
                                "Payment failed. Check your wallet and try again.",
                                "error",
                            );
                        }
                        chatInput.disabled = false;
                        sendBtn.disabled = false;
                        chatInput.focus();
                        activeStatus = null;
                        return;
                    }

                    // Extract payment info (transaction hash + network)
                    const paymentResponse = res.headers.get("payment-response");
                    let payment;
                    if (paymentResponse) {
                        try {
                            payment = JSON.parse(atob(paymentResponse));
                        } catch {}
                    }

                    if (!res.ok) {
                        const body = await res.text();
                        removeStatus(activeStatus);
                        appendMessage(
                            `HTTP ${res.status}: ${body.slice(0, 300)}`,
                            "error",
                        );
                        return;
                    }

                    const contentType = res.headers.get("content-type") || "";

                    if (contentType.includes("text/event-stream")) {
                        updateStatus(activeStatus, "Agent is thinking...");
                        const agentTexts = await readSSEStream(res);
                        removeStatus(activeStatus);
                        if (agentTexts.length > 0) {
                            appendMessage(
                                agentTexts.join("\n"),
                                "agent",
                                payment,
                            );
                        } else {
                            appendMessage(
                                "(no agent response)",
                                "system",
                                payment,
                            );
                        }
                    } else {
                        const data = await res.json();
                        removeStatus(activeStatus);
                        if (data.error) {
                            appendMessage(
                                `RPC error: ${data.error.message || JSON.stringify(data.error)}`,
                                "error",
                            );
                            return;
                        }
                        extractResult(data.result, payment);
                    }
                } catch (err) {
                    if (activeStatus) removeStatus(activeStatus);
                    appendMessage(
                        `Error: ${err.message || String(err)}`,
                        "error",
                    );
                } finally {
                    activeStatus = null;
                    chatInput.disabled = false;
                    sendBtn.disabled = false;
                    chatInput.focus();
                }
            }

            // -----------------------------------------------------------------------
            // Event listeners
            // -----------------------------------------------------------------------
            connectEvmBtn.addEventListener("click", connectEvm);
            disconnectEvmBtn.addEventListener("click", disconnectEvm);
            connectPhantomBtn.addEventListener("click", connectPhantom);
            disconnectPhantomBtn.addEventListener("click", disconnectPhantom);

            sendBtn.addEventListener("click", () => {
                const text = chatInput.value.trim();
                if (text) sendMessage(text);
            });

            chatInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    const text = chatInput.value.trim();
                    if (text) sendMessage(text);
                }
            });

            // MetaMask account/chain changes
            if (window.ethereum) {
                window.ethereum.on("accountsChanged", () => {
                    disconnectEvm();
                    appendMessage(
                        "Account changed. Please reconnect.",
                        "system",
                    );
                });
                window.ethereum.on("chainChanged", (hexId) => {
                    if (!evmWalletClient) return;
                    const newChainId = parseInt(hexId, 16);
                    rebuildEvmWalletClient(newChainId);
                    appendMessage(`Switched to chain ${newChainId}.`, "system");
                    refreshFeedbackRows();
                });
            }

            // Phantom events
            const phantomProvider = window.phantom?.solana;
            if (phantomProvider) {
                phantomProvider.on("disconnect", () => {
                    disconnectPhantom();
                });
                phantomProvider.on("accountChanged", (pk) => {
                    if (pk) {
                        phantomPublicKey = pk.toBase58();
                        const short = `${phantomPublicKey.slice(0, 4)}...${phantomPublicKey.slice(-4)}`;
                        phantomInfoEl.textContent = short;
                        appendMessage("Phantom account changed.", "system");
                    } else {
                        disconnectPhantom();
                    }
                });
            }

            // -----------------------------------------------------------------------
            // Initialize
            // -----------------------------------------------------------------------
            loadAgentCard();
        </script>
    </body>
</html>
